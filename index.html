<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>√áamakoƒülu S√ºlalesi</title>
    <link rel="icon" type="image/ico" href="favicon.ico">
    <link rel="stylesheet" href="css/familienbaum.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Outfit:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        /* Modern Modal Styles */
        #crop-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
        }

        #crop-modal-content {
            background: rgba(255, 255, 255, 0.95);
            margin: auto;
            padding: 32px;
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            width: 90%;
            max-width: 700px;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        #crop-image-container {
            max-height: 60vh;
            overflow: hidden;
            margin-bottom: 24px;
            border-radius: 16px;
            background: #f1f5f9;
        }

        #crop-image-container img {
            max-width: 100%;
            border-radius: 16px;
        }

        .crop-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .crop-actions button {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        #btn-cancel-crop {
            background: #e2e8f0;
            color: #475569;
        }

        #btn-cancel-crop:hover {
            background: #cbd5e0;
        }

        #btn-confirm-crop {
            background: #10b981;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.2);
        }

        #btn-confirm-crop:hover {
            background: #059669;
            box-shadow: 0 10px 15px -3px rgba(16, 185, 129, 0.3);
        }
    </style>
</head>

<body>
    <!-- Global Patrilineal Toggle Button -->
    <div style="position: fixed; top: 24px; right: 24px; z-index: 1000; display: flex; gap: 12px;">
        <button id="share-btn" style="
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 12px 20px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Outfit', sans-serif;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: 0.3px;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.background='rgba(255, 255, 255, 0.2)'; this.style.boxShadow='0 12px 40px 0 rgba(31, 38, 135, 0.25)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.background='rgba(255, 255, 255, 0.1)'; this.style.boxShadow='0 8px 32px 0 rgba(31, 38, 135, 0.15)'">
            <span style="font-size: 1.2em;">üì§</span>
            <span>Payla≈ü</span>
        </button>
        <button id="patrilineal-global-toggle" style="
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 12px 20px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Outfit', sans-serif;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: 0.3px;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.background='rgba(255, 255, 255, 0.2)'; this.style.boxShadow='0 12px 40px 0 rgba(31, 38, 135, 0.25)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.background='rgba(255, 255, 255, 0.1)'; this.style.boxShadow='0 8px 32px 0 rgba(31, 38, 135, 0.15)'">
            <span id="toggle-icon" style="font-size: 1.2em;">üë®‚Äçüë¶</span>
            <span id="toggle-text">Sadece Erkek Soyu</span>
        </button>
    </div>

    <!-- Tree Container (SVG goes here) -->
    <div id="tree-container" style="width:100%; height:100vh;"></div>

    <!-- STATIC SIDEBAR STRUCTURE -->
    <aside id="family-sidebar">
        <div class="sidebar-header">
            <h2 id="sidebar-title">Ki≈üi Adƒ±</h2>
            <button class="close-btn" onclick="closeSidebar()">‚úï</button>
        </div>

        <div class="sidebar-content">
            <!-- Profile Image -->
            <div class="sidebar-section photo-section" style="text-align: center;">
                <div style="position: relative; display: inline-block;">
                    <img id="sidebar-image" src="" alt="Fotoƒüraf"
                        style="max-width: 100%; max-height: 220px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; cursor: pointer; transition: all 0.3s ease;">
                    <button id="delete-photo-btn"
                        style="display: none; position: absolute; top: 8px; right: 8px; background: #c84b4b; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 20px; font-weight: bold; line-height: 1; padding: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s ease;">√ó</button>
                </div>
                <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
            </div>

            <!-- Dynamic Details -->
            <div class="sidebar-section">
                <div id="sidebar-details"></div>
            </div>

            <!-- Action Buttons -->
            <div class="sidebar-section" style="display: flex; flex-direction: column; gap: 10px;">
                <button id="btn-parents" class="action-btn btn-primary">Atalarƒ± G√∂ster (Anne/Baba)</button>
                <button id="btn-children" class="action-btn btn-primary">Torunlarƒ± G√∂ster (√áocuklar)</button>
            </div>


            <!-- Meta -->
            <div class="sidebar-section">
                <button id="btn-open-sheet" class="action-btn btn-secondary" onclick="openSheet()">Google Tablosunu
                    A√ß</button>
            </div>
        </div>
    </aside>

    <!-- CROP MODAL -->
    <div id="crop-modal">
        <div id="crop-modal-content">
            <h3>Fotoƒürafƒ± Kƒ±rp</h3>
            <div id="crop-image-container">
                <img id="image-to-crop" src="">
            </div>
            <div class="crop-actions">
                <button id="btn-cancel-crop" class="action-btn btn-secondary">ƒ∞ptal</button>
                <button id="btn-confirm-crop" class="action-btn btn-success">‚úÇÔ∏è Kƒ±rp ve Y√ºkle</button>
            </div>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="js/d3.v7.min.js"></script>
    <script src="js/dag.js"></script>
    <script src="js/dag_layout.js"></script>
    <script src="js/dag_with_relations.js"></script>
    <script src="js/dag_with_family_data.js"></script>
    <script src="js/dag_relaxation.js"></script>
    <script src="js/familienbaum.js"></script>
    <script src="js/editor.js"></script>
    <script src="js/sheet_loader.js"></script>

    <!-- Minimal Logic for Sidebar Interaction -->
    <script>
        // ============ URL STATE MANAGEMENT MODULE ============
        // Generate persistent ID from member data (human-readable)
        function getPersistentId(member) {
            if (member.persistentId) return member.persistentId;

            // Extract first 3 chars of first name, first 3 of last name, last 2 of birth year
            const firstName = (member.first_name || 'unk').toLowerCase().replace(/[^a-z0-9]/g, '').slice(0, 3);
            const lastName = (member.last_name || 'unk').toLowerCase().replace(/[^a-z0-9]/g, '').slice(0, 3);

            // Extract last 2 digits of birth year
            let yearDigits = '00';
            if (member.birth_date) {
                const yearMatch = member.birth_date.match(/\d{4}/);
                if (yearMatch) {
                    yearDigits = yearMatch[0].slice(-2);
                }
            }

            member.persistentId = `${firstName}_${lastName}_${yearDigits}`;
            return member.persistentId;
        }

        // Map between persistent IDs and mem_X IDs
        const persistentIdMap = new Map(); // persistentId -> mem_X
        const reverseIdMap = new Map();    // mem_X -> persistentId

        function buildIdMaps(familyData) {
            persistentIdMap.clear();
            reverseIdMap.clear();

            const counts = new Map(); // Track duplicates

            for (const memId in familyData.members) {
                const member = familyData.members[memId];
                if (!member.is_spouse || member.first_name) {
                    let persistentId = getPersistentId(member);

                    // Handle duplicates by appending a counter
                    const baseId = persistentId;
                    let counter = counts.get(baseId) || 0;
                    if (counter > 0) {
                        persistentId = `${baseId}_${counter}`;
                    }
                    counts.set(baseId, counter + 1);

                    member.persistentId = persistentId; // Update with deduplicated ID
                    persistentIdMap.set(persistentId, memId);
                    reverseIdMap.set(memId, persistentId);
                }
            }
        }

        // Encode state to URL-friendly base64 string
        function encodeState(currentNode, transform, patrilineal, visibleNodes) {
            const state = {
                n: currentNode ? reverseIdMap.get(currentNode) || null : null,
                t: transform ? { k: transform.k, x: Math.round(transform.x), y: Math.round(transform.y) } : null,
                p: patrilineal ? 1 : 0,
                v: visibleNodes ? Array.from(visibleNodes).map(id => reverseIdMap.get(id)).filter(Boolean) : []
            };

            try {
                const json = JSON.stringify(state);
                return btoa(json).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            } catch (e) {
                console.error('Error encoding state:', e);
                return null;
            }
        }

        // Decode state from URL hash
        function decodeState() {
            try {
                const hash = window.location.hash.slice(1);
                if (!hash) return null;

                // Add padding back
                const base64 = hash.replace(/-/g, '+').replace(/_/g, '/');
                const padding = (4 - base64.length % 4) % 4;
                const padded = base64 + '='.repeat(padding);

                const json = atob(padded);
                const state = JSON.parse(json);

                // Validate state structure
                if (!state || typeof state !== 'object') {
                    console.warn('Invalid URL state: not an object');
                    return null;
                }

                // Convert persistent IDs back to mem_X IDs
                const decoded = {
                    currentNode: null,
                    transform: null,
                    patrilineal: false,
                    visibleNodes: new Set()
                };

                // Restore current node
                if (state.n && persistentIdMap.has(state.n)) {
                    decoded.currentNode = persistentIdMap.get(state.n);
                }

                // Restore transform
                if (state.t && typeof state.t.k === 'number' && typeof state.t.x === 'number' && typeof state.t.y === 'number') {
                    decoded.transform = state.t;
                }

                // Restore patrilineal mode
                decoded.patrilineal = state.p === 1;

                // Restore visible nodes
                if (Array.isArray(state.v)) {
                    for (const pid of state.v) {
                        const memId = persistentIdMap.get(pid);
                        if (memId) {
                            decoded.visibleNodes.add(memId);
                        }
                    }
                }

                console.log('Decoded URL state:', {
                    currentNode: decoded.currentNode,
                    transform: decoded.transform,
                    patrilineal: decoded.patrilineal,
                    visibleCount: decoded.visibleNodes.size
                });

                return decoded;
            } catch (e) {
                console.warn('Error decoding state from URL, falling back to localStorage:', e);
                // Clear invalid hash
                if (window.location.hash) {
                    history.replaceState(null, '', window.location.pathname + window.location.search);
                }
                return null;
            }
        }

        // Update URL hash with current state
        function updateURL() {
            if (!window.familienbaum || !window.familienbaum.g) return;

            const transform = d3.zoomTransform(window.familienbaum.g.node());
            const visibleNodes = new Set();

            if (window.familienbaum.dag_all) {
                for (let node of window.familienbaum.dag_all.nodes()) {
                    if (node.added_data && node.added_data.is_visible) {
                        visibleNodes.add(node.data);
                    }
                }
            }

            const currentNode = window.familyData ? window.familyData.start : null;
            const patrilineal = localStorage.getItem('soyagaci_patrilineal_mode') === 'true';

            const encoded = encodeState(currentNode, transform, patrilineal, visibleNodes);
            if (encoded) {
                history.replaceState(null, '', '#' + encoded);
            }
        }

        // Share functionality with TinyURL
        async function shareCurrentState() {
            const shareBtn = document.getElementById('share-btn');
            const originalContent = shareBtn.innerHTML;

            try {
                // Update URL first to ensure it's current
                updateURL();

                const fullURL = window.location.href;

                // Show loading state
                shareBtn.innerHTML = '<span style="font-size: 1.2em;">‚è≥</span><span>Kƒ±saltƒ±lƒ±yor...</span>';
                shareBtn.disabled = true;

                // Try TinyURL API
                const tinyUrlApi = `https://tinyurl.com/api-create.php?url=${encodeURIComponent(fullURL)}`;
                const response = await fetch(tinyUrlApi);

                if (!response.ok) throw new Error('TinyURL failed');

                const shortURL = await response.text();

                // Copy to clipboard
                await navigator.clipboard.writeText(shortURL);

                // Show success
                shareBtn.innerHTML = '<span style="font-size: 1.2em;">‚úÖ</span><span>Kopyalandƒ±!</span>';
                setTimeout(() => {
                    shareBtn.innerHTML = originalContent;
                    shareBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.warn('TinyURL failed, copying full URL:', error);

                try {
                    // Fallback: copy full URL
                    await navigator.clipboard.writeText(window.location.href);
                    shareBtn.innerHTML = '<span style="font-size: 1.2em;">‚úÖ</span><span>Kopyalandƒ±!</span>';
                    setTimeout(() => {
                        shareBtn.innerHTML = originalContent;
                        shareBtn.disabled = false;
                    }, 2000);
                } catch (clipboardError) {
                    shareBtn.innerHTML = '<span style="font-size: 1.2em;">‚ùå</span><span>Hata!</span>';
                    setTimeout(() => {
                        shareBtn.innerHTML = originalContent;
                        shareBtn.disabled = false;
                    }, 2000);
                }
            }
        }

        // Global UI Functions
        function closeSidebar() {
            document.getElementById('family-sidebar').classList.remove('active');
        }

        function openDriveFolder() {
            window.open("https://drive.google.com/drive/folders/1DzFjTHjzsnM1dcJMF4jZU5RDliCzX0xH?usp=drive_link", "_blank");
        }

        function openSheet() {
            window.open("https://docs.google.com/spreadsheets/d/12kZlANYbq0w3k8TpDxssVSlWVfbs-qZQ9bAjERci0SM/edit?gid=790197592", "_blank");
        }

        // Initialize D3 in specific container
        const svg = d3.select("#tree-container").append("svg").
            attr("width", document.body.offsetWidth).
            attr("height", document.documentElement.clientHeight);

        // Restore Resize Listener
        window.addEventListener("resize", () => {
            svg.attr("width", document.body.offsetWidth)
                .attr("height", document.documentElement.clientHeight);
        });

        // Debounce function for URL updates
        let urlUpdateTimeout;
        function debounceUpdateURL() {
            clearTimeout(urlUpdateTimeout);
            urlUpdateTimeout = setTimeout(updateURL, 500); // Update URL 500ms after user stops interacting
        }

        const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTzo66Bb8-z3QdqtNGZ9uhQJZJxePifl6nJwvtlot-3JtKp4YKYQdqJNFDY89lqHoMRdlKZmjWzh2OA/pub?output=csv";

        async function initApp() {
            let inputData = null;
            try {
                inputData = await loadFromGoogleSheet(SHEET_URL);
                localStorage.setItem('soyagaci_cached_data', JSON.stringify(inputData));
            } catch (e) {
                console.warn("Network failed, trying cache...", e);
                const cached = localStorage.getItem('soyagaci_cached_data');
                if (cached) inputData = JSON.parse(cached);
            }

            if (!inputData) {
                alert("Could not load data.");
                return;
            }

            // Expose data globally for editor
            window.familyData = inputData;
            window.fullFamilyData = JSON.parse(JSON.stringify(inputData)); // Keep full copy

            // Build persistent ID mappings
            buildIdMaps(window.fullFamilyData);

            // Try to restore state from URL first, then fall back to localStorage
            let urlState = decodeState();
            let patrilinealMode = false;
            let lastNodeId = null;
            let savedVisibleNodes = null;
            let savedTransform = null;

            if (urlState) {
                // URL state takes priority
                console.log('Loading state from URL');
                patrilinealMode = urlState.patrilineal;
                lastNodeId = urlState.currentNode;
                savedVisibleNodes = urlState.visibleNodes;
                savedTransform = urlState.transform;
            } else {
                // Fall back to localStorage
                console.log('Loading state from localStorage');
                patrilinealMode = localStorage.getItem('soyagaci_patrilineal_mode') === 'true';
                lastNodeId = localStorage.getItem('soyagaci_last_node');

                const savedVisibleNodesJson = localStorage.getItem('soyagaci_visible_nodes');
                if (savedVisibleNodesJson) {
                    try {
                        savedVisibleNodes = new Set(JSON.parse(savedVisibleNodesJson));
                    } catch (e) { console.warn("Failed to restore visible nodes", e); }
                }

                const savedTransformJson = localStorage.getItem('soyagaci_view_transform');
                if (savedTransformJson) {
                    try {
                        savedTransform = JSON.parse(savedTransformJson);
                    } catch (e) { console.warn("Failed to restore transform", e); }
                }
            }

            // Set start node if we have one
            if (lastNodeId && inputData.members[lastNodeId]) {
                inputData.start = lastNodeId;
            }

            // Global Patrilineal Toggle
            const globalToggle = document.getElementById('patrilineal-global-toggle');
            const toggleIcon = document.getElementById('toggle-icon');
            const toggleText = document.getElementById('toggle-text');

            // Apply initial filter if needed
            if (patrilinealMode) {
                window.familyData = filterPatrilineal(window.fullFamilyData);
                if (globalToggle) {
                    globalToggle.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                    toggleIcon.textContent = 'üë®‚Äçüë¶‚Äçüë¶';
                    toggleText.textContent = 'T√ºm Soy Aƒüacƒ±';
                }
            }

            // We no longer pass 'detailsDiv' to constructor because we manage it globally now
            let familienbaum = new Familienbaum(window.familyData, svg);
            window.familienbaum = familienbaum; // Expose globally for URL state management

            // Restore visible nodes from URL state or localStorage
            if (savedVisibleNodes && savedVisibleNodes.size > 0) {
                if (familienbaum.dag_all) {
                    console.log('Restoring', savedVisibleNodes.size, 'visible nodes');

                    // First, mark the saved nodes as visible
                    for (let node of familienbaum.dag_all.nodes()) {
                        if (savedVisibleNodes.has(node.data)) {
                            node.added_data.is_visible = true;
                        }
                    }

                    // Then, for each saved visible node, also mark their immediate relationships as visible
                    // This ensures connections between nodes are shown correctly
                    for (let node of familienbaum.dag_all.nodes()) {
                        if (savedVisibleNodes.has(node.data)) {
                            const relationships = familienbaum.get_relationship_in_dag_all(node);
                            for (let relNode of relationships) {
                                // Mark relationship nodes visible if they connect saved visible nodes
                                if (savedVisibleNodes.has(relNode.data) || relNode.data.startsWith('u_')) {
                                    relNode.added_data.is_visible = true;
                                }
                            }
                        }
                    }
                }
            }

            familienbaum.draw(false); // Draw without auto-centering initially

            // Restore zoom/pan from URL state or localStorage
            if (savedTransform) {
                try {
                    const transform = d3.zoomIdentity.translate(savedTransform.x, savedTransform.y).scale(savedTransform.k);
                    svg.call(familienbaum.zoom.transform, transform);
                } catch (e) { console.warn("Failed to restore transform", e); }
            } else {
                // If no saved transform, do the initial center
                // We need to find the current node to center on
                let current_node = familienbaum.dag.find_node(window.familyData.start);
                if (current_node) {
                    svg.transition().duration(0).call(
                        familienbaum.zoom.transform,
                        d3.zoomTransform(familienbaum.g.node())
                            .translate(current_node.added_data.y0 - current_node.y,
                                current_node.added_data.x0 - current_node.x),
                    );
                }
            }

            // Save state function
            function saveState() {
                localStorage.setItem('soyagaci_patrilineal_mode', patrilinealMode);

                if (familienbaum && familienbaum.g) {
                    const transform = d3.zoomTransform(familienbaum.g.node());
                    localStorage.setItem('soyagaci_view_transform', JSON.stringify({ k: transform.k, x: transform.x, y: transform.y }));

                    if (familienbaum.dag_all) {
                        const visibleNodes = [];
                        for (let node of familienbaum.dag_all.nodes()) {
                            if (node.added_data && node.added_data.is_visible) {
                                visibleNodes.push(node.data);
                            }
                        }
                        localStorage.setItem('soyagaci_visible_nodes', JSON.stringify(visibleNodes));
                    }
                }
            }

            // Save on unload
            window.addEventListener("beforeunload", saveState);

            if (globalToggle) {
                globalToggle.addEventListener('click', () => {
                    // Save state before toggling (to capture current view)
                    // Actually, we want to capture the view *before* the toggle changes it, 
                    // but the user might want to return to this view. 
                    // However, the toggle logic below handles the immediate transition.
                    // The saveState is mainly for reload. 
                    // But we should update the patrilinealMode variable.

                    // CAPTURE STATE for immediate transition
                    let savedTransform = d3.zoomIdentity;
                    let savedVisibleNodes = new Set();

                    if (familienbaum && familienbaum.g) {
                        savedTransform = d3.zoomTransform(familienbaum.g.node());
                        if (familienbaum.dag_all) {
                            for (let node of familienbaum.dag_all.nodes()) {
                                if (node.added_data && node.added_data.is_visible) {
                                    savedVisibleNodes.add(node.data);
                                }
                            }
                        }
                    }

                    patrilinealMode = !patrilinealMode;
                    // Save the new mode immediately so it persists if they reload right after
                    localStorage.setItem('soyagaci_patrilineal_mode', patrilinealMode);

                    // Clear SVG before redrawing to prevent overlapping
                    svg.selectAll("*").remove();

                    if (patrilinealMode) {
                        // Enable patrilineal mode
                        globalToggle.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                        toggleIcon.textContent = 'üë®‚Äçüë¶‚Äçüë¶';
                        toggleText.textContent = 'T√ºm Soy Aƒüacƒ±';

                        const filteredData = filterPatrilineal(window.fullFamilyData);
                        window.familyData = filteredData;
                        familienbaum = new Familienbaum(filteredData, svg);
                    } else {
                        // Disable patrilineal mode - show all
                        globalToggle.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                        toggleIcon.textContent = 'üë®‚Äçüë¶';
                        toggleText.textContent = 'Sadece Erkek Soyu';

                        window.familyData = JSON.parse(JSON.stringify(window.fullFamilyData));
                        familienbaum = new Familienbaum(window.familyData, svg);
                    }

                    // RESTORE STATE
                    if (familienbaum && familienbaum.dag_all) {
                        for (let node of familienbaum.dag_all.nodes()) {
                            if (savedVisibleNodes.has(node.data)) {
                                node.added_data.is_visible = true;
                            }
                        }
                    }

                    // Draw without recentering to preserve position
                    familienbaum.draw(false);

                    // Apply saved transform
                    if (familienbaum.zoom) {
                        svg.call(familienbaum.zoom.transform, savedTransform);
                    }

                    // Save state after toggle to persist the new view
                    saveState();
                });
            }
        }

        // Filter data to show only patrilineal descendants
        function filterPatrilineal(data) {
            console.log("Starting patrilineal filter, total members:", Object.keys(data.members).length);
            console.log("Displayed root:", data.start, data.members[data.start]?.name);

            const filtered = {
                start: null, // Will be set after determining lineage
                members: {},
                links: []
            };

            // Build parent-child relationships
            const unionToParents = {};
            const childToUnion = {};

            for (const link of data.links) {
                const [from, to] = link;
                if (from.startsWith('u_')) {
                    childToUnion[to] = from;
                } else if (to.startsWith('u_')) {
                    if (!unionToParents[to]) unionToParents[to] = [];
                    unionToParents[to].push(from);
                }
            }

            // Track which members are in the male lineage (Strictly Father -> Son)
            const maleLineage = new Set();
            const processed = new Set();

            // Find the actual tree root (lowest generation number)
            let actualRoot = data.start;
            let lowestGen = Infinity;
            for (const memberId in data.members) {
                const member = data.members[memberId];
                if (!member.is_spouse && member.gen < lowestGen) {
                    lowestGen = member.gen;
                    actualRoot = memberId;
                }
            }
            console.log("Actual tree root:", actualRoot, data.members[actualRoot]?.name, "gen:", lowestGen);

            // Helper to get blood parent (non-spouse parent)
            function getBloodParent(memberId) {
                const parentUnion = childToUnion[memberId];
                if (!parentUnion) return null;

                const parents = unionToParents[parentUnion] || [];
                for (const parentId of parents) {
                    const parent = data.members[parentId];
                    if (parent && !parent.is_spouse) {
                        return parentId;
                    }
                }
                return null;
            }

            // Recursively check if someone is in male lineage
            function isInMaleLineage(memberId) {
                if (processed.has(memberId)) {
                    return maleLineage.has(memberId);
                }
                processed.add(memberId);

                const member = data.members[memberId];
                if (!member) {
                    return false;
                }

                // Actual tree root is always in lineage
                if (memberId === actualRoot) {
                    maleLineage.add(memberId);
                    return true;
                }

                // Spouses are not in lineage (they'll be added separately)
                if (member.is_spouse) {
                    return false;
                }

                // Check if descended from male lineage
                const bloodParentId = getBloodParent(memberId);
                if (!bloodParentId) {
                    return false; // No parent, not in lineage
                }

                const bloodParent = data.members[bloodParentId];

                // Must be male AND parent must be male AND parent must be in male lineage
                if (member.gender === 'E' && bloodParent.gender === 'E' && isInMaleLineage(bloodParentId)) {
                    maleLineage.add(memberId);
                    return true;
                }

                return false;
            }

            // First pass: identify all male lineage members
            for (const memberId in data.members) {
                isInMaleLineage(memberId);
            }

            console.log("Male lineage members:", maleLineage.size);

            // If the displayed root is not in male lineage, switch to actual root
            const displayRoot = maleLineage.has(data.start) ? data.start : actualRoot;
            console.log("Using display root:", displayRoot, data.members[displayRoot]?.name);

            // Second pass: Identify who to DISPLAY
            // Rule:
            // 1. Members in Male Lineage
            // 2. Children of Members in Male Lineage (includes daughters)
            // 3. Spouses of anyone in 1 or 2

            const displayedMembers = new Set();

            for (const memberId in data.members) {
                const member = data.members[memberId];

                if (maleLineage.has(memberId)) {
                    displayedMembers.add(memberId);
                } else if (!member.is_spouse) {
                    // Check if parent is in male lineage
                    const bloodParentId = getBloodParent(memberId);
                    if (bloodParentId && maleLineage.has(bloodParentId)) {
                        displayedMembers.add(memberId);
                    }
                }
            }

            // Add spouses of displayed members
            for (const memberId in data.members) {
                const member = data.members[memberId];
                if (member.is_spouse) {
                    // Check if partner is displayed
                    const parentUnion = childToUnion[memberId];
                    if (parentUnion) {
                        const parents = unionToParents[parentUnion] || [];
                        for (const parentId of parents) {
                            if (displayedMembers.has(parentId)) {
                                displayedMembers.add(memberId);
                                break;
                            }
                        }
                    } else {
                        // Spouse without parent union - check unions they're part of
                        for (const link of data.links) {
                            const [from, to] = link;
                            if (from === memberId && to.startsWith('u_')) {
                                // This spouse is in a union
                                const partners = unionToParents[to] || [];
                                for (const partnerId of partners) {
                                    if (partnerId !== memberId && displayedMembers.has(partnerId)) {
                                        displayedMembers.add(memberId);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Populate filtered members
            for (const memberId of displayedMembers) {
                filtered.members[memberId] = data.members[memberId];
            }

            // Filter links
            for (const link of data.links) {
                const [from, to] = link;

                if (to.startsWith('u_') || from.startsWith('u_')) {
                    // Union link - include if at least one end is included
                    const fromIncluded = from.startsWith('u_') || filtered.members[from];
                    const toIncluded = to.startsWith('u_') || filtered.members[to];

                    if (fromIncluded && toIncluded) {
                        filtered.links.push(link);
                    }
                } else {
                    // Direct link
                    if (filtered.members[from] && filtered.members[to]) {
                        filtered.links.push(link);
                    }
                }
            }

            console.log("Filtered members count:", Object.keys(filtered.members).length);
            console.log("Filtered links count:", filtered.links.length);

            // SAFEGUARD: Ensure display root is in members
            if (!filtered.members[displayRoot]) {
                console.warn("Display root", displayRoot, "was missing from filtered members! Adding it forcibly.");
                filtered.members[displayRoot] = data.members[displayRoot];
            }

            // DEBUG: Check if display root is in any link
            const rootInLinks = filtered.links.some(link => link[0] === displayRoot || link[1] === displayRoot);
            if (!rootInLinks) {
                console.warn("Display root", displayRoot, "is NOT in any filtered link! This will cause 'Node not found' error.");
                // Attempt to find at least one link for the root
                const rootLinks = data.links.filter(link => link[0] === displayRoot || link[1] === displayRoot);
                console.log("Original links for root:", rootLinks);
            }

            filtered.start = displayRoot;
            return filtered;
        }

        // Shift Key Listeners
        document.addEventListener('keydown', (e) => { if (e.key === 'Shift') document.body.classList.add('show-plus'); });
        document.addEventListener('keyup', (e) => { if (e.key === 'Shift') document.body.classList.remove('show-plus'); });

        // Wire up Share button
        const shareBtn = document.getElementById('share-btn');
        if (shareBtn) {
            shareBtn.addEventListener('click', shareCurrentState);
        }

        initApp();
    </script>
</body>

</html>
