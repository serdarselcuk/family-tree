<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>√áamakoƒülu S√ºlalesi</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="css/familienbaum.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Outfit:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        /* Modern Modal Styles */
        #crop-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
        }

        #crop-modal-content {
            background: rgba(255, 255, 255, 0.95);
            margin: auto;
            padding: 32px;
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            width: 90%;
            max-width: 700px;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        #crop-image-container {
            max-height: 60vh;
            overflow: hidden;
            margin-bottom: 24px;
            border-radius: 16px;
            background: #f1f5f9;
        }

        #crop-image-container img {
            max-width: 100%;
            border-radius: 16px;
        }

        .crop-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .crop-actions button {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        #btn-cancel-crop {
            background: #e2e8f0;
            color: #475569;
        }

        #btn-cancel-crop:hover {
            background: #cbd5e0;
        }

        #btn-confirm-crop {
            background: #10b981;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.2);
        }

        #btn-confirm-crop:hover {
            background: #059669;
            box-shadow: 0 10px 15px -3px rgba(16, 185, 129, 0.3);
        }
    </style>
</head>

<body>
    <!-- Global Patrilineal Toggle Button -->
    <div style="position: fixed; top: 24px; right: 24px; z-index: 1000;">
        <button id="patrilineal-global-toggle" style="
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 12px 20px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Outfit', sans-serif;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: 0.3px;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.background='rgba(255, 255, 255, 0.2)'; this.style.boxShadow='0 12px 40px 0 rgba(31, 38, 135, 0.25)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.background='rgba(255, 255, 255, 0.1)'; this.style.boxShadow='0 8px 32px 0 rgba(31, 38, 135, 0.15)'">
            <span id="toggle-icon" style="font-size: 1.2em;">üë®‚Äçüë¶</span>
            <span id="toggle-text">Sadece Erkek Soyu</span>
        </button>
    </div>

    <!-- Tree Container (SVG goes here) -->
    <div id="tree-container" style="width:100%; height:100vh;"></div>

    <!-- STATIC SIDEBAR STRUCTURE -->
    <aside id="family-sidebar">
        <div class="sidebar-header">
            <h2 id="sidebar-title">Ki≈üi Adƒ±</h2>
            <button class="close-btn" onclick="closeSidebar()">‚úï</button>
        </div>

        <div class="sidebar-content">
            <!-- Profile Image -->
            <div class="sidebar-section photo-section" style="text-align: center;">
                <div style="position: relative; display: inline-block;">
                    <img id="sidebar-image" src="" alt="Fotoƒüraf"
                        style="max-width: 100%; max-height: 220px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; cursor: pointer; transition: all 0.3s ease;">
                    <button id="delete-photo-btn"
                        style="display: none; position: absolute; top: 8px; right: 8px; background: #c84b4b; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 20px; font-weight: bold; line-height: 1; padding: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s ease;">√ó</button>
                </div>
                <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
            </div>

            <!-- Dynamic Details -->
            <div class="sidebar-section">
                <div id="sidebar-details"></div>
            </div>

            <!-- Action Buttons -->
            <div class="sidebar-section" style="display: flex; flex-direction: column; gap: 10px;">
                <button id="btn-parents" class="action-btn btn-primary">Atalarƒ± G√∂ster (Anne/Baba)</button>
                <button id="btn-children" class="action-btn btn-primary">Torunlarƒ± G√∂ster (√áocuklar)</button>
            </div>


            <!-- Meta -->
            <div class="sidebar-section">
                <button id="btn-open-sheet" class="action-btn btn-secondary" onclick="openSheet()">Google Tablosunu
                    A√ß</button>
            </div>
        </div>
    </aside>

    <!-- CROP MODAL -->
    <div id="crop-modal">
        <div id="crop-modal-content">
            <h3>Fotoƒürafƒ± Kƒ±rp</h3>
            <div id="crop-image-container">
                <img id="image-to-crop" src="">
            </div>
            <div class="crop-actions">
                <button id="btn-cancel-crop" class="action-btn btn-secondary">ƒ∞ptal</button>
                <button id="btn-confirm-crop" class="action-btn btn-success">‚úÇÔ∏è Kƒ±rp ve Y√ºkle</button>
            </div>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="js/d3.v7.min.js"></script>
    <script src="js/dag.js"></script>
    <script src="js/dag_layout.js"></script>
    <script src="js/dag_with_relations.js"></script>
    <script src="js/dag_with_family_data.js"></script>
    <script src="js/dag_relaxation.js"></script>
    <script src="js/familienbaum.js"></script>
    <script src="js/editor.js"></script>
    <script src="js/sheet_loader.js"></script>

    <!-- Minimal Logic for Sidebar Interaction -->
    <script>
        // Global UI Functions
        function closeSidebar() {
            document.getElementById('family-sidebar').classList.remove('active');
        }

        function openDriveFolder() {
            window.open("https://drive.google.com/drive/folders/1DzFjTHjzsnM1dcJMF4jZU5RDliCzX0xH?usp=drive_link", "_blank");
        }

        function openSheet() {
            window.open("https://docs.google.com/spreadsheets/d/12kZlANYbq0w3k8TpDxssVSlWVfbs-qZQ9bAjERci0SM/edit?gid=790197592", "_blank");
        }

        // Initialize D3 in specific container
        const svg = d3.select("#tree-container").append("svg").
            attr("width", document.body.offsetWidth).
            attr("height", document.documentElement.clientHeight);

        // Restore Resize Listener
        window.addEventListener("resize", () => {
            svg.attr("width", document.body.offsetWidth)
                .attr("height", document.documentElement.clientHeight);
        });

        const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTzo66Bb8-z3QdqtNGZ9uhQJZJxePifl6nJwvtlot-3JtKp4YKYQdqJNFDY89lqHoMRdlKZmjWzh2OA/pub?output=csv";

        async function initApp() {
            let inputData = null;
            try {
                inputData = await loadFromGoogleSheet(SHEET_URL);
            } catch (e) {
                console.warn("Failed to load data", e);
            }

            if (!inputData) {
                alert("Could not load data.");
                return;
            }

            // State Management via URL
            function getUrlState() {
                const hash = window.location.hash.substring(1);
                if (!hash) return null;
                const params = new URLSearchParams(hash);
                return {
                    start: params.get("node"),
                    zoom: params.get("zoom") ? params.get("zoom").split(",").map(Number) : null,
                    visible: params.get("visible") ? new Set(params.get("visible").split(",")) : null
                };
            }

            function updateUrlState() {
                if (!familienbaum || !familienbaum.g) return;

                const t = d3.zoomTransform(familienbaum.g.node());
                const zoomStr = `${t.k.toFixed(3)},${t.x.toFixed(1)},${t.y.toFixed(1)}`;
                
                const visibleNodes = [];
                if (familienbaum.dag_all) {
                    for (let node of familienbaum.dag_all.nodes()) {
                        if (node.added_data && node.added_data.is_visible) {
                            visibleNodes.push(node.data);
                        }
                    }
                }
                
                const params = new URLSearchParams();
                if (familienbaum.data.start) params.set("node", familienbaum.data.start);
                params.set("zoom", zoomStr);
                if (visibleNodes.length > 0) params.set("visible", visibleNodes.join(","));

                history.replaceState(null, null, "#" + params.toString());
            }

            // ID Recovery Helper
            function findClosestId(targetId, members) {
                if (!targetId) return null;
                // 1. Exact match
                if (members[targetId]) return targetId;
                
                // 2. Try to recover from date/suffix change
                if (!targetId.startsWith('mem_')) return null;
                
                // Heuristic: Remove the last segment if it's numeric (year or counter)
                const parts = targetId.split('_');
                // Expected min: mem_name (2 parts) - but usually mem_name_surname (3) or mem_name_year (3)
                if (parts.length < 3) return null; 
                
                // Try removing up to 2 segments (e.g. year and counter) to find a stable prefix
                // e.g. mem_ahmet_1980 -> mem_ahmet
                for (let i = 1; i <= 2; i++) {
                    if (parts.length <= 2) break;
                    parts.pop();
                    const prefix = parts.join('_');
                    
                    // Look for any ID starting with this prefix
                    const match = Object.keys(members).find(id => id.startsWith(prefix));
                    if (match) {
                        console.log(`Recovered ID: ${targetId} -> ${match}`);
                        return match;
                    }
                }
                return null;
            }

            function resolveIdSet(idSet, members) {
                const resolved = new Set();
                if (!idSet) return resolved;
                for (const id of idSet) {
                    const match = findClosestId(id, members);
                    if (match) resolved.add(match);
                }
                return resolved;
            }

            // Check URL state first
            const urlState = getUrlState();
            
            // Determine start node with recovery
            let requestedStart = (urlState && urlState.start) 
                ? urlState.start 
                : localStorage.getItem('soyagaci_last_node');

            let resolvedStart = findClosestId(requestedStart, inputData.members);
            
            if (resolvedStart) {
                inputData.start = resolvedStart;
            }

            // Expose data globally for editor
            window.familyData = inputData;
            window.fullFamilyData = JSON.parse(JSON.stringify(inputData)); // Keep full copy

            // Global Patrilineal Toggle
            let patrilinealMode = localStorage.getItem('soyagaci_patrilineal_mode') === 'true';
            const globalToggle = document.getElementById('patrilineal-global-toggle');
            const toggleIcon = document.getElementById('toggle-icon');
            const toggleText = document.getElementById('toggle-text');

            // Apply initial filter if needed
            if (patrilinealMode) {
                window.familyData = filterPatrilineal(window.fullFamilyData);
                if (globalToggle) {
                    globalToggle.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                    toggleIcon.textContent = 'üë®‚Äçüë¶‚Äçüë¶';
                    toggleText.textContent = 'T√ºm Soy Aƒüacƒ±';
                }
            }

            // We no longer pass 'detailsDiv' to constructor because we manage it globally now
            let familienbaum = new Familienbaum(window.familyData, svg, () => {
                // Debounce URL update to avoid history flood during animation
                if (window.urlUpdateTimeout) clearTimeout(window.urlUpdateTimeout);
                window.urlUpdateTimeout = setTimeout(updateUrlState, 500);
            });

            // Restore visible nodes
            if (urlState && urlState.visible) {
                 if (familienbaum.dag_all) {
                    const resolvedVisible = resolveIdSet(urlState.visible, inputData.members);
                    // Reset all to invisible first (except start, which reset_dags handles, but we overwrite)
                    for (let node of familienbaum.dag_all.nodes()) {
                        node.added_data.is_visible = resolvedVisible.has(node.data);
                    }
                    // Ensure start node is visible
                    const startNode = familienbaum.dag_all.find_node(window.familyData.start);
                    if (startNode) startNode.added_data.is_visible = true;
                }
            } else {
                const savedVisibleNodesJson = localStorage.getItem('soyagaci_visible_nodes');
                if (savedVisibleNodesJson) {
                    try {
                        const rawSet = new Set(JSON.parse(savedVisibleNodesJson));
                        const resolvedVisible = resolveIdSet(rawSet, inputData.members);
                        if (familienbaum.dag_all) {
                            for (let node of familienbaum.dag_all.nodes()) {
                                if (resolvedVisible.has(node.data)) {
                                    node.added_data.is_visible = true;
                                }
                            }
                        }
                    } catch (e) { console.warn("Failed to restore visible nodes", e); }
                }
            }

            familienbaum.draw(false); // Draw without auto-centering initially

            // Restore zoom/pan
            if (urlState && urlState.zoom) {
                const [k, x, y] = urlState.zoom;
                if (!isNaN(k) && !isNaN(x) && !isNaN(y)) {
                    const transform = d3.zoomIdentity.translate(x, y).scale(k);
                    svg.call(familienbaum.zoom.transform, transform);
                }
            } else {
                const savedTransformJson = localStorage.getItem('soyagaci_view_transform');
                if (savedTransformJson) {
                    try {
                        const t = JSON.parse(savedTransformJson);
                        const transform = d3.zoomIdentity.translate(t.x, t.y).scale(t.k);
                        svg.call(familienbaum.zoom.transform, transform);
                    } catch (e) { console.warn("Failed to restore transform", e); }
                } else {
                    // If no saved transform, do the initial center
                    // We need to find the current node to center on
                    let current_node = familienbaum.dag.find_node(window.familyData.start);
                    if (current_node) {
                        svg.transition().duration(0).call(
                            familienbaum.zoom.transform,
                            d3.zoomTransform(familienbaum.g.node())
                                .translate(current_node.added_data.y0 - current_node.y,
                                    current_node.added_data.x0 - current_node.x),
                        );
                    }
                }
            }

            // Save state function
            function saveState() {
                localStorage.setItem('soyagaci_patrilineal_mode', patrilinealMode);

                if (familienbaum && familienbaum.g) {
                    const transform = d3.zoomTransform(familienbaum.g.node());
                    localStorage.setItem('soyagaci_view_transform', JSON.stringify({ k: transform.k, x: transform.x, y: transform.y }));

                    if (familienbaum.dag_all) {
                        const visibleNodes = [];
                        for (let node of familienbaum.dag_all.nodes()) {
                            if (node.added_data && node.added_data.is_visible) {
                                visibleNodes.push(node.data);
                            }
                        }
                        localStorage.setItem('soyagaci_visible_nodes', JSON.stringify(visibleNodes));
                    }
                }
            }

            // Save on unload
            window.addEventListener("beforeunload", saveState);

            if (globalToggle) {
                globalToggle.addEventListener('click', () => {
                    // Save state before toggling (to capture current view)
                    // Actually, we want to capture the view *before* the toggle changes it, 
                    // but the user might want to return to this view. 
                    // However, the toggle logic below handles the immediate transition.
                    // The saveState is mainly for reload. 
                    // But we should update the patrilinealMode variable.

                    // CAPTURE STATE for immediate transition
                    let savedTransform = d3.zoomIdentity;
                    let savedVisibleNodes = new Set();

                    if (familienbaum && familienbaum.g) {
                        savedTransform = d3.zoomTransform(familienbaum.g.node());
                        if (familienbaum.dag_all) {
                            for (let node of familienbaum.dag_all.nodes()) {
                                if (node.added_data && node.added_data.is_visible) {
                                    savedVisibleNodes.add(node.data);
                                }
                            }
                        }
                    }

                    patrilinealMode = !patrilinealMode;
                    // Save the new mode immediately so it persists if they reload right after
                    localStorage.setItem('soyagaci_patrilineal_mode', patrilinealMode);

                    // Clear SVG before redrawing to prevent overlapping
                    svg.selectAll("*").remove();

                    if (patrilinealMode) {
                        // Enable patrilineal mode
                        globalToggle.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                        toggleIcon.textContent = 'üë®‚Äçüë¶‚Äçüë¶';
                        toggleText.textContent = 'T√ºm Soy Aƒüacƒ±';

                        const filteredData = filterPatrilineal(window.fullFamilyData);
                        window.familyData = filteredData;
                        familienbaum = new Familienbaum(filteredData, svg);
                    } else {
                        // Disable patrilineal mode - show all
                        globalToggle.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                        toggleIcon.textContent = 'üë®‚Äçüë¶';
                        toggleText.textContent = 'Sadece Erkek Soyu';

                        window.familyData = JSON.parse(JSON.stringify(window.fullFamilyData));
                        familienbaum = new Familienbaum(window.familyData, svg);
                    }

                    // RESTORE STATE
                    if (familienbaum && familienbaum.dag_all) {
                        for (let node of familienbaum.dag_all.nodes()) {
                            if (savedVisibleNodes.has(node.data)) {
                                node.added_data.is_visible = true;
                            }
                        }
                    }

                    // Draw without recentering to preserve position
                    familienbaum.draw(false);

                    // Apply saved transform
                    if (familienbaum.zoom) {
                        svg.call(familienbaum.zoom.transform, savedTransform);
                    }

                    // Save state after toggle to persist the new view
                    saveState();
                });
            }
        }

        // Filter data to show only patrilineal descendants
        function filterPatrilineal(data) {
            console.log("Starting patrilineal filter, total members:", Object.keys(data.members).length);
            console.log("Displayed root:", data.start, data.members[data.start]?.name);

            const filtered = {
                start: null, // Will be set after determining lineage
                members: {},
                links: []
            };

            // Build parent-child relationships
            const unionToParents = {};
            const childToUnion = {};

            for (const link of data.links) {
                const [from, to] = link;
                if (from.startsWith('u_')) {
                    childToUnion[to] = from;
                } else if (to.startsWith('u_')) {
                    if (!unionToParents[to]) unionToParents[to] = [];
                    unionToParents[to].push(from);
                }
            }

            // Track which members are in the male lineage (Strictly Father -> Son)
            const maleLineage = new Set();
            const processed = new Set();

            // Find the actual tree root (lowest generation number)
            let actualRoot = data.start;
            let lowestGen = Infinity;
            for (const memberId in data.members) {
                const member = data.members[memberId];
                if (!member.is_spouse && member.gen < lowestGen) {
                    lowestGen = member.gen;
                    actualRoot = memberId;
                }
            }
            console.log("Actual tree root:", actualRoot, data.members[actualRoot]?.name, "gen:", lowestGen);

            // Helper to get blood parent (non-spouse parent)
            function getBloodParent(memberId) {
                const parentUnion = childToUnion[memberId];
                if (!parentUnion) return null;

                const parents = unionToParents[parentUnion] || [];
                for (const parentId of parents) {
                    const parent = data.members[parentId];
                    if (parent && !parent.is_spouse) {
                        return parentId;
                    }
                }
                return null;
            }

            // Recursively check if someone is in male lineage
            function isInMaleLineage(memberId) {
                if (processed.has(memberId)) {
                    return maleLineage.has(memberId);
                }
                processed.add(memberId);

                const member = data.members[memberId];
                if (!member) {
                    return false;
                }

                // Actual tree root is always in lineage
                if (memberId === actualRoot) {
                    maleLineage.add(memberId);
                    return true;
                }

                // Spouses are not in lineage (they'll be added separately)
                if (member.is_spouse) {
                    return false;
                }

                // Check if descended from male lineage
                const bloodParentId = getBloodParent(memberId);
                if (!bloodParentId) {
                    return false; // No parent, not in lineage
                }

                const bloodParent = data.members[bloodParentId];

                // Must be male AND parent must be male AND parent must be in male lineage
                if (member.gender === 'E' && bloodParent.gender === 'E' && isInMaleLineage(bloodParentId)) {
                    maleLineage.add(memberId);
                    return true;
                }

                return false;
            }

            // First pass: identify all male lineage members
            for (const memberId in data.members) {
                isInMaleLineage(memberId);
            }

            console.log("Male lineage members:", maleLineage.size);

            // If the displayed root is not in male lineage, switch to actual root
            const displayRoot = maleLineage.has(data.start) ? data.start : actualRoot;
            console.log("Using display root:", displayRoot, data.members[displayRoot]?.name);

            // Second pass: Identify who to DISPLAY
            // Rule:
            // 1. Members in Male Lineage
            // 2. Children of Members in Male Lineage (includes daughters)
            // 3. Spouses of anyone in 1 or 2

            const displayedMembers = new Set();

            for (const memberId in data.members) {
                const member = data.members[memberId];

                if (maleLineage.has(memberId)) {
                    displayedMembers.add(memberId);
                } else if (!member.is_spouse) {
                    // Check if parent is in male lineage
                    const bloodParentId = getBloodParent(memberId);
                    if (bloodParentId && maleLineage.has(bloodParentId)) {
                        displayedMembers.add(memberId);
                    }
                }
            }

            // Add spouses of displayed members
            for (const memberId in data.members) {
                const member = data.members[memberId];
                if (member.is_spouse) {
                    // Check if partner is displayed
                    const parentUnion = childToUnion[memberId];
                    if (parentUnion) {
                        const parents = unionToParents[parentUnion] || [];
                        for (const parentId of parents) {
                            if (displayedMembers.has(parentId)) {
                                displayedMembers.add(memberId);
                                break;
                            }
                        }
                    } else {
                        // Spouse without parent union - check unions they're part of
                        for (const link of data.links) {
                            const [from, to] = link;
                            if (from === memberId && to.startsWith('u_')) {
                                // This spouse is in a union
                                const partners = unionToParents[to] || [];
                                for (const partnerId of partners) {
                                    if (partnerId !== memberId && displayedMembers.has(partnerId)) {
                                        displayedMembers.add(memberId);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Populate filtered members
            for (const memberId of displayedMembers) {
                filtered.members[memberId] = data.members[memberId];
            }

            // Filter links
            for (const link of data.links) {
                const [from, to] = link;

                if (to.startsWith('u_') || from.startsWith('u_')) {
                    // Union link - include if at least one end is included
                    const fromIncluded = from.startsWith('u_') || filtered.members[from];
                    const toIncluded = to.startsWith('u_') || filtered.members[to];

                    if (fromIncluded && toIncluded) {
                        filtered.links.push(link);
                    }
                } else {
                    // Direct link
                    if (filtered.members[from] && filtered.members[to]) {
                        filtered.links.push(link);
                    }
                }
            }

            console.log("Filtered members count:", Object.keys(filtered.members).length);
            console.log("Filtered links count:", filtered.links.length);

            // SAFEGUARD: Ensure display root is in members
            if (!filtered.members[displayRoot]) {
                console.warn("Display root", displayRoot, "was missing from filtered members! Adding it forcibly.");
                filtered.members[displayRoot] = data.members[displayRoot];
            }

            // DEBUG: Check if display root is in any link
            const rootInLinks = filtered.links.some(link => link[0] === displayRoot || link[1] === displayRoot);
            if (!rootInLinks) {
                console.warn("Display root", displayRoot, "is NOT in any filtered link! This will cause 'Node not found' error.");
                // Attempt to find at least one link for the root
                const rootLinks = data.links.filter(link => link[0] === displayRoot || link[1] === displayRoot);
                console.log("Original links for root:", rootLinks);
            }

            filtered.start = displayRoot;
            return filtered;
        }

        // Shift Key Listeners
        document.addEventListener('keydown', (e) => { if (e.key === 'Shift') document.body.classList.add('show-plus'); });
        document.addEventListener('keyup', (e) => { if (e.key === 'Shift') document.body.classList.remove('show-plus'); });

        initApp();
    </script>
</body>

</html>